#!/usr/bin/python2.7

"""
Supplementary Note 2: Center Weighting

Authors: Eugene Oh, Annemarie Becker

Modified for RNAseq by: Johannes Asplund-Samuelsson (KTH)

inputFile:
.map file generated by Bowtie default output.

outputFileP:
read density file for plus strand
    col0: position along genome
    col1: read density at that position

outputFileM:
read density file for minus strand
    col0: position along genome
    col1: read density at that position

"""


def rawdata(inputFile, outputFileP, outputFileM, min_length, max_length):

    pDict = {}
    mDict = {}

    inFile = open(inputFile, 'r')
    line = inFile.readline()
    while line != '':
        fields = line.split("\t")
        col2 = str(fields[1])   #strand; note: if sequencing was performed without barcode reading, the column numbering is changed
        col3 = str(fields[2])   #seq-id
        col4 = int(fields[3])   #left-most position
        col5 = str(fields[4])   #read seq
        length = len(col5)      #read length

        # Consider only reads within min and max
        if min_length <= length <= max_length:

            if col2 == '+':	#for plus strand
                end5 = col4 + 1 #Bowtie uses zero-based offset, transform to 1-based
                end3 = end5 + length - 1
                # Assign the 5 prime end of the read to the genome position
                if col3 not in pDict:
                    pDict[col3] = {}
                try:
                    pDict[col3][end5] += 1.0
                except KeyError:
                    pDict[col3][end5] = 1.0

            elif col2 == '-': #for minus strand
                end3 = col4 + 1 #for minus strand, Bowtie gives leftmost position (3' end) with zero-based numbering
                end5 = end3 + length - 1
                # Assign the 5 prime end of the read to the genome position
                if col3 not in mDict:
                    mDict[col3] = {}
                try:
                    mDict[col3][end5] += 1.0
                except KeyError:
                    mDict[col3][end5] = 1.0

        line = inFile.readline()

    def write_readcount(outputFile, Dict):
        outFile = open(outputFile, 'w')
        for ref_sequence in Dict:
            List = Dict[ref_sequence].items()
            List.sort()
            for J in List:
                output = '\t'.join([ref_sequence, str(J[0]), str(J[1])]) + '\n'
                outFile.write(output)
        outFile.close()

    write_readcount(outputFileP, pDict)
    write_readcount(outputFileM, mDict)


if __name__=='__main__':
    # Parse commandline arguments
    import argparse

    parser = argparse.ArgumentParser()

    parser.add_argument('-i', '--infile', help='Input file (bwt).')
    parser.add_argument('--outP', help='Output file P.')
    parser.add_argument('--outM', help='Output file M.')
    parser.add_argument('--min', help='Min. length.', type=int)
    parser.add_argument('--max', help='Max. length.', type=int)

    args = parser.parse_args()

    inputFile = args.infile
    outputFileP = args.outP
    outputFileM = args.outM
    min_length = args.min
    max_length = args.max

    rawdata(inputFile, outputFileP, outputFileM, min_length, max_length)
